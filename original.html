<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tagged Prompt Editor</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
      /* 커스텀 스크롤바 스타일 */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #2d3748;
      }
      ::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #718096;
      }
      /* contenteditable 플레이스홀더 스타일 */
      [contenteditable]:empty:before {
        content: attr(placeholder);
        pointer-events: none;
        display: block;
        color: #718096;
      }
      #autocomplete-suggestions .suggestion-item.active {
        background-color: #4a5568;
      }
      /* Visual Block 비활성화 스타일 */
      .is-disabled {
        opacity: 0.6;
        border-color: #4a5568 !important;
        background-color: rgba(45, 55, 72, 0.8);
      }
      .is-disabled .pl-4,
      .is-disabled [contenteditable='true'] {
        pointer-events: none;
        user-select: none;
      }
      .is-disabled [contenteditable='true'] {
        cursor: not-allowed;
      }
      /* Raw Text 비활성화 스타일 */
      .raw-text-disabled {
        color: #6b7280;
        /* text-decoration: line-through; */
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-200 font-sans antialiased">
    <div id="app" class="flex flex-col h-screen">
      <header class="bg-gray-800 border-b border-gray-700 p-4 shadow-md">
        <h1 class="text-xl font-bold text-cyan-400">Tagged Prompt Editor</h1>
        <p class="text-sm text-gray-400 mt-1">
          왼쪽에 텍스트를 입력/수정하면 오른쪽 블록이 실시간으로 업데이트됩니다.
        </p>
      </header>

      <main class="flex-grow flex flex-col md:flex-row gap-4 p-4 overflow-hidden">
        <!-- Left Panel: Raw Text Editor -->
        <div
          class="relative flex-1 flex flex-col bg-gray-800 rounded-lg shadow-lg border border-gray-700"
        >
          <div
            class="bg-gray-700/50 px-4 py-2 rounded-t-lg border-b border-gray-600 flex justify-between items-center"
          >
            <h2 class="font-semibold text-gray-300">Raw XML/HTML Text</h2>
            <button
              id="copy-btn"
              class="bg-gray-600 hover:bg-cyan-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors duration-200"
            >
              Copy
            </button>
          </div>
          <div class="relative flex-grow w-full font-mono text-base">
            <textarea
              id="raw-text"
              class="absolute top-0 left-0 w-full h-full bg-transparent p-4 resize-none focus:outline-none z-10"
              style="
                color: transparent;
                caret-color: white;
                white-space: pre;
                overflow-wrap: normal;
              "
              wrap="off"
              placeholder="여기에 프롬프트를 입력하세요..."
            ></textarea>
            <pre
              id="raw-text-display"
              class="absolute top-0 left-0 w-full h-full bg-transparent p-4 text-gray-300 pointer-events-none z-0"
              style="white-space: pre; overflow-wrap: normal"
            ></pre>
          </div>
          <div
            id="autocomplete-suggestions"
            class="hidden absolute bg-gray-700 border border-gray-600 rounded-md shadow-lg text-sm z-50"
          ></div>
        </div>

        <!-- Right Panel: Rendered Blocks -->
        <div class="flex-1 flex flex-col bg-gray-800 rounded-lg shadow-lg border border-gray-700">
          <div class="bg-gray-700/50 px-4 py-2 rounded-t-lg border-b border-gray-600">
            <h2 class="font-semibold text-gray-300">Visual Block Renderer</h2>
          </div>
          <div id="rendered-view" class="flex-grow p-4 overflow-y-auto space-y-3">
            <!-- Rendered blocks will be injected here -->
          </div>
        </div>
      </main>
    </div>

    <script>
      const rawTextElement = document.getElementById('raw-text')
      const rawTextDisplayElement = document.getElementById('raw-text-display')
      const renderedViewElement = document.getElementById('rendered-view')
      const suggestionsBox = document.getElementById('autocomplete-suggestions')
      const copyBtn = document.getElementById('copy-btn')

      let parsedData = []
      let uniqueIdCounter = 0
      let activeSuggestionIndex = -1

      const initialContent = `<지시사항>
# AI 기술 분석 요청

아래 \`<문서>\` 태그 안의 내용을 분석하여, 다음 세 가지 항목을 요약해 주세요.

- **핵심 주제**: 문서가 말하고자 하는 가장 중요한 내용은 무엇인가?
- **긍정적 측면**: AI 기술의 어떤 장점들이 언급되었는가?
- **비판적 측면**: 어떤 윤리적 문제나 단점들이 제기되었는가?
</지시사항>

<문서들>
    <메타정보>
        <저자>AI 전문가</저자>
        <버전>1.0</버전>
    </메타정보>
    <ai-문서>
인공지능(AI) 기술은 현대 사회의 많은 문제를 해결할 잠재력을 가지고 있습니다. 의료 분야에서는 질병 진단을 돕고, 교통 분야에서는 자율주행차를 통해 사고를 줄일 수 있습니다. 

하지만 일자리 대체, 데이터 편향성, 그리고 통제 불가능한 AI의 등장과 같은 윤리적 문제도 함께 제기되고 있어 신중한 접근이 필요합니다.
    </ai-문서>
</문서들>

<스타일가이드>
- 각 요약은 명확하고 간결한 문장으로 작성
- 전문 용어 사용 최소화
</스타일가이드>`

      marked.setOptions({ gfm: true, breaks: true })

      function parseText(text) {
        const nodes = []
        const regex = /<([^<>\s\/]+)[\s\S]*?>([\s\S]*?)<\/\1>/g
        let match
        let lastIndex = 0
        while ((match = regex.exec(text)) !== null) {
          const precedingText = text.substring(lastIndex, match.index)
          if (precedingText.trim()) {
            nodes.push({
              id: uniqueIdCounter++,
              type: 'text',
              content: precedingText.trim(),
              enabled: true,
            })
          }
          const tagName = match[1]
          const innerContent = match[2]
          nodes.push({
            id: uniqueIdCounter++,
            type: 'element',
            tagName: tagName,
            children: parseText(innerContent),
            enabled: true,
          })
          lastIndex = regex.lastIndex
        }
        const trailingText = text.substring(lastIndex)
        if (trailingText.trim()) {
          nodes.push({
            id: uniqueIdCounter++,
            type: 'text',
            content: trailingText.trim(),
            enabled: true,
          })
        }
        if (nodes.length === 0 && text) {
          if (text.trim().length > 0) {
            return [{ id: uniqueIdCounter++, type: 'text', content: text, enabled: true }]
          }
        }
        return nodes
      }

      function renderBlocksRecursive(nodes, container, parentDisabled = false) {
        nodes.forEach((item) => {
          const isDisabledNode = parentDisabled || item.enabled === false
          if (item.type === 'element') {
            const block = document.createElement('div')
            block.className =
              'bg-gray-700/50 border border-gray-600 rounded-lg p-3 transition-all duration-200 hover:border-cyan-500/50'
            const header = document.createElement('div')
            header.className = 'flex items-center justify-between mb-2'

            const tagInput = document.createElement('div')
            tagInput.contentEditable = true
            tagInput.dataset.id = item.id
            tagInput.textContent = item.tagName
            tagInput.className =
              'bg-cyan-900/50 text-cyan-300 text-sm font-semibold px-2 py-1 rounded focus:outline-none focus:ring-2 focus:ring-cyan-400 cursor-text'

            const toggleLabel = document.createElement('label')
            toggleLabel.className = 'relative inline-flex items-center cursor-pointer'
            const toggleInput = document.createElement('input')
            toggleInput.type = 'checkbox'
            toggleInput.checked = item.enabled !== false
            toggleInput.className = 'sr-only peer'
            const toggleDiv = document.createElement('div')
            toggleDiv.className =
              "w-9 h-5 bg-gray-600 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-cyan-800 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-cyan-600"
            toggleLabel.appendChild(toggleInput)
            toggleLabel.appendChild(toggleDiv)

            header.appendChild(tagInput)
            header.appendChild(toggleLabel)

            block.appendChild(header)
            const contentContainer = document.createElement('div')
            contentContainer.className = 'pl-4 border-l-2 border-gray-600 space-y-2'
            block.appendChild(contentContainer)

            block.classList.toggle('is-disabled', isDisabledNode)
            if (isDisabledNode) tagInput.contentEditable = false

            toggleInput.addEventListener('change', () => {
              updateNodeValue(item.id, 'enabled', toggleInput.checked)
              renderView() // Re-render everything to reflect state change
            })

            if (item.children && item.children.length > 0) {
              renderBlocksRecursive(item.children, contentContainer, isDisabledNode)
            } else {
              const emptyPlaceholder = document.createElement('div')
              emptyPlaceholder.textContent = '클릭하여 텍스트를 추가하세요...'
              emptyPlaceholder.className =
                'text-gray-500 italic p-2 rounded cursor-pointer hover:bg-gray-600/30 transition-colors text-sm'
              emptyPlaceholder.addEventListener('click', () => {
                if (isDisabledNode) return
                initiateNewTextNodeCreation(item, contentContainer)
              })
              contentContainer.appendChild(emptyPlaceholder)
            }
            container.appendChild(block)
            tagInput.addEventListener('input', (e) =>
              updateNodeValue(parseInt(e.target.dataset.id), 'tagName', e.target.textContent),
            )
          } else if (item.type === 'text') {
            const textContainer = document.createElement('div')
            const renderMarkdownView = (content) => {
              textContainer.innerHTML = ''
              const displayDiv = document.createElement('div')
              displayDiv.className =
                'prose prose-sm prose-invert max-w-none p-2 rounded cursor-pointer hover:bg-gray-600/30 transition-colors'
              displayDiv.innerHTML = marked.parse(content || ' ')
              displayDiv.addEventListener('click', () => {
                if (isDisabledNode) return
                editMarkdownView(content)
              })
              textContainer.appendChild(displayDiv)
            }
            const editMarkdownView = (currentContent) => {
              textContainer.innerHTML = ''
              const textarea = document.createElement('textarea')
              textarea.className =
                'w-full bg-gray-900 text-gray-300 p-2 rounded border border-cyan-500 focus:outline-none resize-none'
              textarea.value = currentContent
              const autoResize = () => {
                textarea.style.height = 'auto'
                textarea.style.height = textarea.scrollHeight + 'px'
              }
              textarea.addEventListener('input', autoResize)
              textarea.addEventListener('blur', () => {
                const newContent = textarea.value
                updateNodeValue(item.id, 'content', newContent)
                renderMarkdownView(newContent)
              })
              textContainer.appendChild(textarea)
              textarea.focus()
              autoResize()
            }
            renderMarkdownView(item.content)
            container.appendChild(textContainer)
          }
        })
      }

      function renderView() {
        renderedViewElement.innerHTML = ''
        if (parsedData.length > 0) {
          renderBlocksRecursive(parsedData, renderedViewElement)
        } else if (rawTextElement.value.trim()) {
          renderedViewElement.innerHTML = `<div class="text-center text-gray-500 p-8">왼쪽 텍스트 영역에 유효한 태그를 입력해 주세요. (예: &lt;tag&gt;내용&lt;/tag&gt;)</div>`
        }
      }

      function initiateNewTextNodeCreation(parentNode, container) {
        container.innerHTML = '' // Clear the placeholder text
        const textarea = document.createElement('textarea')
        textarea.className =
          'w-full bg-gray-900 text-gray-300 p-2 rounded border border-cyan-500 focus:outline-none resize-none'
        textarea.value = ''

        const autoResize = () => {
          textarea.style.height = 'auto'
          textarea.style.height = textarea.scrollHeight + 'px'
        }
        textarea.addEventListener('input', autoResize)

        const saveAndRender = () => {
          const newContent = textarea.value.trim()
          textarea.removeEventListener('blur', saveAndRender)

          if (newContent) {
            const newNode = { type: 'text', content: newContent, enabled: true }
            if (!parentNode.children) {
              parentNode.children = []
            }
            parentNode.children.push(newNode)
            rebuildAndSetRawText()
            uniqueIdCounter = 0
            parsedData = parseText(rawTextElement.value)
            renderView()
          } else {
            renderView()
          }
        }

        textarea.addEventListener('blur', saveAndRender)
        container.appendChild(textarea)
        textarea.focus()
        autoResize()
      }

      function findAndUpdateNode(nodes, id, key, value) {
        for (const node of nodes) {
          if (node.id === id) {
            node[key] = value
            return true
          }
          if (
            node.type === 'element' &&
            node.children &&
            findAndUpdateNode(node.children, id, key, value)
          ) {
            return true
          }
        }
        return false
      }

      function updateNodeValue(id, key, value) {
        if (findAndUpdateNode(parsedData, id, key, value)) {
          rebuildAndSetRawText()
        }
      }

      function buildStringFromNode(node, indent = 0) {
        const indentStr = ' '.repeat(indent * 4)
        if (node.type === 'text') {
          return node.content.trim() ? indentStr + node.content.trim() : ''
        }
        if (node.type === 'element') {
          const tagName = node.tagName || 'div'
          if (node.children.length === 0) {
            return `${indentStr}<${tagName}></${tagName}>`
          }
          const isSingleLineContent =
            node.children.length === 1 &&
            node.children[0].type === 'text' &&
            !node.children[0].content.includes('\n')
          if (isSingleLineContent) {
            return `${indentStr}<${tagName}>${node.children[0].content.trim()}</${tagName}>`
          } else {
            const childrenStr = node.children
              .map((child) => buildStringFromNode(child, indent + 1))
              .join('\n')
            return `${indentStr}<${tagName}>\n${childrenStr}\n${indentStr}</${tagName}>`
          }
        }
        return ''
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;')
      }

      function buildRawTextHTML(node, indent = 0, parentDisabled = false) {
        const isDisabled = parentDisabled || node.enabled === false
        const indentStr = ' '.repeat(indent * 4)
        const spanStart = `<span class="${isDisabled ? 'raw-text-disabled' : ''}">`
        const spanEnd = `</span>`

        if (node.type === 'text') {
          return node.content.trim()
            ? `${spanStart}${escapeHTML(indentStr + node.content.trim())}${spanEnd}`
            : ''
        }
        if (node.type === 'element') {
          const tagName = node.tagName || 'div'
          if (node.children.length === 0) {
            return `${spanStart}${escapeHTML(`${indentStr}<${tagName}></${tagName}>`)}${spanEnd}`
          }
          const isSingleLineContent =
            node.children.length === 1 &&
            node.children[0].type === 'text' &&
            !node.children[0].content.includes('\n')
          if (isSingleLineContent) {
            return `${spanStart}${escapeHTML(`${indentStr}<${tagName}>${node.children[0].content.trim()}</${tagName}>`)}${spanEnd}`
          } else {
            const childrenStr = node.children
              .map((child) => buildRawTextHTML(child, indent + 1, isDisabled))
              .join('\n')
            return `${spanStart}${escapeHTML(`${indentStr}<${tagName}>`)}${spanEnd}\n${childrenStr}\n${spanStart}${escapeHTML(`${indentStr}</${tagName}>`)}${spanEnd}`
          }
        }
        return ''
      }

      function buildCopyableString(nodes) {
        return nodes
          .map((node) => {
            if (node.enabled === false) return ''
            return buildStringFromNode(node)
          })
          .filter((s) => s)
          .join('\n\n')
      }

      function rebuildAndSetRawText() {
        // Update textarea value (for logic)
        const newText = parsedData.map((node) => buildStringFromNode(node)).join('\n\n')
        const cursorPosition = rawTextElement.selectionStart
        rawTextElement.value = newText
        try {
          rawTextElement.setSelectionRange(cursorPosition, cursorPosition)
        } catch (e) {
          /* ignore */
        }

        // Update display div (for visuals)
        const newHtml = parsedData.map((node) => buildRawTextHTML(node)).join('\n\n')
        rawTextDisplayElement.innerHTML = newHtml
      }

      // --- Autocomplete Logic ---
      function getOpenTags(text, cursorPosition) {
        const contentBeforeCursor = text.substring(0, cursorPosition)
        const stack = []
        const tagRegex = /<\/?([^<>\s\/]+)[\s\S]*?>/g
        let match
        while ((match = tagRegex.exec(contentBeforeCursor)) !== null) {
          const tagName = match[1]
          if (match[0].startsWith('</')) {
            if (stack.length > 0 && stack[stack.length - 1] === tagName) {
              stack.pop()
            }
          } else if (!match[0].endsWith('/>')) {
            stack.push(tagName)
          }
        }
        return stack
      }

      function getCaretCoordinates(element, position) {
        const mirrorDiv = document.createElement('div')
        document.body.appendChild(mirrorDiv)
        const style = window.getComputedStyle(element)
        ;[
          'border',
          'boxSizing',
          'fontFamily',
          'fontSize',
          'fontWeight',
          'height',
          'letterSpacing',
          'lineHeight',
          'padding',
          'textDecoration',
          'textIndent',
          'textTransform',
          'whiteSpace',
          'wordSpacing',
          'wordWrap',
          'width',
          'overflowWrap',
        ].forEach((prop) => {
          mirrorDiv.style[prop] = style[prop]
        })
        mirrorDiv.style.position = 'absolute'
        mirrorDiv.style.visibility = 'hidden'
        mirrorDiv.style.overflow = 'auto'
        mirrorDiv.style.whiteSpace = 'pre'
        mirrorDiv.style.overflowWrap = 'normal'
        mirrorDiv.textContent = element.value.substring(0, position)
        const span = document.createElement('span')
        span.textContent = '.'
        span.style.visibility = 'hidden'
        mirrorDiv.appendChild(span)
        const coordinates = {
          top: span.offsetTop + parseInt(style['borderTopWidth']),
          left: span.offsetLeft + parseInt(style['borderLeftWidth']),
          height: parseInt(style['lineHeight']),
        }
        document.body.removeChild(mirrorDiv)
        return coordinates
      }

      function showSuggestions(tags, textarea) {
        if (tags.length === 0) {
          hideSuggestions()
          return
        }
        suggestionsBox.innerHTML = ''
        tags.forEach((tag, index) => {
          const item = document.createElement('div')
          item.textContent = tag
          if (index === 0) {
            item.className = 'px-3 py-2 cursor-pointer suggestion-item font-bold text-cyan-300'
          } else {
            item.className = 'px-3 py-2 cursor-pointer suggestion-item text-gray-400'
          }
          item.addEventListener('click', () => selectSuggestion(tag))
          suggestionsBox.appendChild(item)
        })
        const coords = getCaretCoordinates(textarea, textarea.selectionStart)
        const container = textarea.parentElement
        suggestionsBox.style.top = `${textarea.offsetTop + coords.top - textarea.scrollTop + coords.height}px`
        suggestionsBox.style.left = `${textarea.offsetLeft + coords.left - textarea.scrollLeft}px`
        suggestionsBox.classList.remove('hidden')
        activeSuggestionIndex = 0
        updateActiveSuggestion()
      }

      function hideSuggestions() {
        suggestionsBox.classList.add('hidden')
        activeSuggestionIndex = -1
      }

      function updateActiveSuggestion() {
        const items = suggestionsBox.querySelectorAll('.suggestion-item')
        items.forEach((item, index) => {
          item.classList.toggle('active', index === activeSuggestionIndex)
        })
      }

      function selectSuggestion(tag) {
        const start = rawTextElement.selectionStart
        const value = rawTextElement.value
        const textToInsert = '</' + tag + '>'
        rawTextElement.value = value.substring(0, start - 2) + textToInsert + value.substring(start)
        const newCursorPos = start - 2 + textToInsert.length
        rawTextElement.selectionStart = rawTextElement.selectionEnd = newCursorPos
        hideSuggestions()
        handleRawInput()
        rawTextElement.focus()
      }

      function handleRawInput() {
        const value = rawTextElement.value
        const start = rawTextElement.selectionStart

        if (value.substring(start - 2, start) === '</') {
          const openTags = getOpenTags(value, start - 2)
          showSuggestions(openTags.reverse(), rawTextElement)
        } else {
          hideSuggestions()
        }

        // Sync display with textarea content while typing
        rawTextDisplayElement.innerHTML = escapeHTML(value)

        uniqueIdCounter = 0
        parsedData = parseText(rawTextElement.value)
        // After parsing, re-apply styles
        const newHtml = parsedData.map((node) => buildRawTextHTML(node)).join('\n\n')
        if (newHtml) rawTextDisplayElement.innerHTML = newHtml

        renderView()
      }

      function handleShortcuts(e) {
        if (!suggestionsBox.classList.contains('hidden')) {
          const items = suggestionsBox.querySelectorAll('.suggestion-item')
          if (e.key === 'ArrowDown' || (e.key === 'Tab' && !e.shiftKey)) {
            e.preventDefault()
            activeSuggestionIndex = (activeSuggestionIndex + 1) % items.length
            updateActiveSuggestion()
          } else if (e.key === 'ArrowUp' || (e.key === 'Tab' && e.shiftKey)) {
            e.preventDefault()
            activeSuggestionIndex = (activeSuggestionIndex - 1 + items.length) % items.length
            updateActiveSuggestion()
          } else if (e.key === 'Enter') {
            e.preventDefault()
            if (activeSuggestionIndex > -1) {
              selectSuggestion(items[activeSuggestionIndex].textContent)
            }
          } else if (e.key === 'Escape') {
            e.preventDefault()
            hideSuggestions()
          }
          return
        }

        // Other shortcuts remain the same
      }

      function initialize() {
        rawTextElement.value = initialContent
        rawTextElement.addEventListener('keydown', handleShortcuts)
        rawTextElement.addEventListener('input', handleRawInput)
        rawTextElement.addEventListener('scroll', () => {
          rawTextDisplayElement.scrollTop = rawTextElement.scrollTop
          rawTextDisplayElement.scrollLeft = rawTextElement.scrollLeft
        })
        document.addEventListener('click', (e) => {
          if (!suggestionsBox.contains(e.target) && e.target !== rawTextElement) {
            hideSuggestions()
          }
        })

        copyBtn.addEventListener('click', () => {
          const textToCopy = buildCopyableString(parsedData)
          navigator.clipboard
            .writeText(textToCopy)
            .then(() => {
              copyBtn.textContent = 'Copied!'
              setTimeout(() => {
                copyBtn.textContent = 'Copy'
              }, 1500)
            })
            .catch((err) => {
              console.error('Failed to copy: ', err)
              copyBtn.textContent = 'Error'
              setTimeout(() => {
                copyBtn.textContent = 'Copy'
              }, 1500)
            })
        })

        handleRawInput()
      }

      initialize()
    </script>
  </body>
</html>
